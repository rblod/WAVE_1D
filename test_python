    import numpy as np
    from scipy.interpolate   import interp1d
    from scipy.sparse.linalg import spsolve
    from scipy.optimize import fsolve, root

    from math  import pi
    import os

    from explicitFILT0 import *
    from InterpItoJ    import *
    from jonswap_blw   import *
    from Comp_1st_Mat  import *
    from Cell_J_Mat    import *
    from Deriv1j       import *
    from deriv1i       import *
    from Comp_2nd_Mat  import *
    from Deriv2j       import *
    from opfiles       import *
    from VolIntMat     import *
    from CellFaceInt   import *
    from WaveProp      import * 
    from BrWaveIndex   import *
    from EddyViscosity import *
    from FluxContinuity import *
    from FluxMomentum import * 
    from SourceMomentum import *
    from findposRL1 import *
    from findposRL2 import *
    from DataManip import *
    from DeffCorrU import *

    RootFolder=os.getcwd()
    miter=1
    tfin=1
    tend=1
    t=0
    #tfin=120;#1490;
    tfin=tend
    #Initialisation des variables
    kk=miter
    Cr=1
    tini=0
    Tf=tend
    Ti=tini
    if 1==1:
        STO=1
        mycmd='mkdir -p '+RootFolder+'/results/calc0'+str(kk)
        os.system(mycmd)
        carpetaN=RootFolder+'/results/calc0'+str(kk)
        carpetaO=RootFolder+'/results/calc0'+str(kk)
        tini=t
        mycmd='cd '+RootFolder
        os.system(mycmd)


    # ----------------------------------------------------------------------------------------------------
    # --------------------------------------- Main Routine -----------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    # Method :
    # Numerical Method solving the Serre Equations for uneven bottoms
    # 4th order finite volume for spatial discretization
    # 4th order Runge-Kutta method for time stepping
    # Modified equations from Seabra-Santos et al. (1987)
    # Retaining terms of order O(sigma^2) and Pade [2,2] linear dispersion correction based on Madsen et al. (1991)
    #-
    # History
    # 4/02/2019 : Rachid Benshila LEGOS-CNRS    , Python version 
    # 4/01/2010 : Rodrigo Cienfuegos C. LEGI-PUC, Initial version
    # ----------------------------------------------------------------------------------------------------
    
#RB  lastwarn('')
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Problem definition and parameters -------------------------------------
    # ----------------------------------------------------------------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # Downward gravitational acceleration (m\s^2)
    # ----------------------------------------------------------------------------------------------------
    #-
    g = 9.81

    # ----------------------------------------------------------------------------------------------------
    #-
    Zprof = np.load( RootFolder+'/Zprof.npy' )

    # ----------------------------------------------------------------------------------------------------
    #
# Incident wave field
#Profondeur d'eau au large
    h0 = abs(Zprof[0])
    H0 = 0.5    
    a0 = H0/.2
    T0 = 10
    
    c0 = (g*h0)** 0.5    
    L0 = c0*T0    
    k0 = 2*pi/L0    
    epsilon = a0/h0    
    kh0 = k0*h0    
    offset = 0
        
    # ----------------------------------------------------------------------------------------------------
    # Wave breaking parametrization
    # ----------------------------------------------------------------------------------------------------
    #-
    PHIb = 28.*pi / 180.    
    PHIf =  8.*pi / 180.    
    PHI1 = 13.*pi / 180.    
    PHI2 = 13.*pi / 180.    
    gamab = 0.8    
    gamaf = 0.8   
    kap1 = 0.1    
    kap2 = 0.1    
    alfab = 5.0    
    alfaf = 5.0   
    kTb = 5.0    
    bCointe = 0.796
        
    # ----------------------------------------------------------------------------------------------------
    # Numerical discretization
    # ----------------------------------------------------------------------------------------------------
    #-
    ro = 0.1    
    dx = ro*h0    
    dt = Cr/(g*h0)**0.5*dx    
    WDtol = 0.0001
        
    # ----------------------------------------------------------------------------------------------------
    # Linear dispersion correction (Madsen et al., 1991)
    # ----------------------------------------------------------------------------------------------------
    #-
    alfa = 1./15.
        
    # ----------------------------------------------------------------------------------------------------
    # Friction coefficient
    # ----------------------------------------------------------------------------------------------------
    #-
    fricFact = 0    
    Cf = 0.015
    
    
    # ----------------------------------------------------------------------------------------------------
    # Filtering Wet domain
    # ----------------------------------------------------------------------------------------------------
    #-
    FilterD1 = 1   
    FilterD2 = 1  
    NSZ = 15    
    NIZ = 15    
    NFT = 0    
    alfaF = 0.4
    
    # ----------------------------------------------------------------------------------------------------
    # Parameter values for Picard iterations in deferred-correction approach
    # ----------------------------------------------------------------------------------------------------
    #-
    MaxIter = 10    
    tol = 1e-05
    
    # ----------------------------------------------------------------------------------------------------
    # Dispersion terms (betaD=1 : Activate dispersif terms ; betaD=0 : Neglect dispersif terms)
    # ----------------------------------------------------------------------------------------------------
    #-
    betaD = 1

    # ----------------------------------------------------------------------------------------------------
    # Bottom bathymetry and physical domain (wet & dry)
    # ----------------------------------------------------------------------------------------------------
    #-
    slope = 0.02
    
    xf = np.arange( 1, len(Zprof)+1 )
    zf = Zprof
    zf[0:3] = zf[0]

    Xlong=max(xf)+dx    
    Xj = np.arange( xf[0], Xlong, dx )    
    Xi = np.arange( xf[0] + dx/2., Xlong-dx/2., dx )
    
    set_interp = interp1d( xf, zf, kind='linear', fill_value='extrapolate' )
    fi = set_interp( Xi )
    fi = explicitFILT0( fi )

    set_interp = interp1d( Xi, fi, kind='linear', fill_value='extrapolate' )
    fj = set_interp( Xj[len(Xj)-1] )  
    fj = InterpItoJ( fi, zf[0], fj )
    
    Ntot=len(Xj)
    
    N=min( np.min( np.where(fj > 0) ), np.max( np.where(fj <= 0) ) )
    
    Next=N + NSZ
    
    Nint=N - NIZ
    
    # ----------------------------------------------------------------------------------------------------
    # Wave forcing
    # ----------------------------------------------------------------------------------------------------
    #-
    
    # load([RootFolder,'/serie_temp_jonswap_sensi_terrasse_slope']);
# ii=find(etahf(1:end-1)<=0&etahf(2:end)>0);
# etahf=etahf(ii(1):end);tti=tti(ii(1):end);tti=tti-min(tti);
    
    Tp1 = 10
    a1 = 0.5
    dt = 0.01
    ff,SSm,tt,etahf,eta,etaLB = jonswap_blw( 1000, int(1./dt), 1./Tp1, a1, 100, 3, 3, 3, nargout=6 )
 
    DAT = np.zeros( [len(tt), 2] )
    DAT[:,0] = tt
    DAT[:,1] = etahf
    Cfi = Cf*np.ones( [Ntot] )
        
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Output files with results and parameters ------------------------------ 
    # ----------------------------------------------------------------------------------------------------
    #-
    # Rows = spatial coordinate
    # Columns = temporal coordinate
    #-
    fidParam,fidXj,fidXi,fidFj,fidFxj,fidFxxj,fidHj,fidHi,fidUj,fidUi,fidUxj,fidUxxj,fidNUj,fidTime,fidNwet,fidXb,fidHout=opfiles(carpetaN,RootFolder)
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Constant Matrix Generation ---------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    ADxj  = Comp_1st_Mat( Ntot   )    
    ADxi  = Comp_1st_Mat( Ntot-1 )     
    ADxxj = Comp_2nd_Mat( Ntot   )    
    AD  = Comp_1st_Mat( Ntot-2 )    
    ADi = Comp_1st_Mat( Ntot-3 )    
    BQ = Cell_J_Mat( Ntot )
    
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Bottom's derivative estimate ------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    Dxfj=Deriv1j(fj,dx,ADxj)
    Dxfi=deriv1i(fi,fj[0],fj[Ntot-1],dx,ADxi)
    Dxxfj=Deriv2j(fj,dx,ADxxj)

    #    fidXj.write('%6.4f \\t' % elem for elem in Xj)
    #    fidXi.write('%6.4f \\t',Xi)
    #    fidFj.write('%6.4f \\t',fj)
    #    fidFxj.write('%6.4f \\t',Dxfj)
    #    fidFxxj.write('%6.4f \\t',Dxxfj)

    np.savetxt( carpetaN+'/Xj.dat'  , Xj   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Xi.dat'  , Xi   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fj.dat'  , fj   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fxj.dat' , Dxfj ,  fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fxxj.dat', Dxxfj, fmt='%6.4f', delimiter='\t' )
    
    # ----------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------------- Initial Conditions ----------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # Initial conditions for water depth h and depth-averaged velocity u at cell faces (j nodes)
    # ----------------------------------------------------------------------------------------------------
    #-
    t0 = Ti
    
    
    if t0 == 0:
        hj = -fj[0:Ntot]
        uj = np.zeros( [Ntot] )
        hi = -fi[0:Ntot-1]
        set_interp = interp1d( Xj, uj, kind='cubic' )
        ui = set_interp(Xi)
    else:
        hj, uj, hi, ui, t0 = readLastLine( carpetaO, RootFolder, nargout=5 )
        
    # ----------------------------------------------------------------------------------------------------
    # Initial condition for auxiliary variable q at cell faces (j nodes)
    # ----------------------------------------------------------------------------------------------------
    #- 

    #-   
    # Cell-averaged values for depth-averaged velocity at j cells
    #-
    Uj = np.zeros([Ntot])
    Uj[0]=2./3.*uj[0] + 1./6.*( 5*ui[0] - 6.*ui[1] + 4.*ui[2] - ui[3])    
    Uj[1:Ntot-1]=2./3.*uj[1:Ntot-1] + 1./6.*( ui[0:Ntot - 2] + ui[1:Ntot - 1])    
    Uj[Ntot-1]=2./3.*uj[Ntot-1] + 1./6.*(5.*ui[Ntot-2] - 6*ui[Ntot-3] + 4.*ui[Ntot-4] - ui[Ntot-5])
    
    Dxui=deriv1i(ui,uj[0],uj[Ntot-1],dx,ADxi)    
    Dxhj=Deriv1j(hj,dx,ADxj)
    
    rj=betaD*((Dxhj[0:Ntot]+Dxfj[0:Ntot])*Dxfj[0:Ntot]+1./2.*hj[0:Ntot]*Dxxfj[0:Ntot])  # Auxiliary variable r at j nodes
    hi0   = 4.*hi[0]  -6.*hi [1]+4.*hi  [2]-  hi[3]                              # cubic extrapolation
    Dxui0 = 4.*Dxui[0]-6*Dxui[1]+4.*Dxui[2]-Dxui[3]                              # cubic extrapolation
    hiN   = 4.*hi  [Ntot-2]-6*hi  [Ntot-3]+4.*hi  [Ntot-4]-hi  [Ntot-5]          # cubic extrapolation
    DxuiN = 4.*Dxui[Ntot-2]-6*Dxui[Ntot-3]+4.*Dxui[Ntot-4]-Dxui[Ntot-5]          # cubic extrapolation
    
    #-
    # Cell-averaged values for auxiliary variable q at j cells
    #- 
    Qj = np.zeros( [Ntot] )
    Qj[0       ] = (1+rj[0])*Uj[0]+betaD*np.array([-1./(3.*dx*hj[0])*(hi[0]**3*Dxui[0]-hi0**3*Dxui0)-alfa/dx*fj[0]**2*(Dxui[0]-Dxui0)]) # Boundary node
    Qj[1:Ntot-1] = (1+rj[1:Ntot-1])*Uj[1:Ntot-1]+betaD*(-1./(3.*dx*hj[1:Ntot-1])*(hi[1:Ntot-1]**3*Dxui[1:Ntot-1]-hi[0:Ntot-2]**3*Dxui[0:Ntot-2])-alfa/dx*fj[1:Ntot-1]**2*(Dxui[1:Ntot-1]-Dxui[0:Ntot-2]))#Internal nodes
    Qj[Ntot-1  ] = (1+rj[Ntot-1])*Uj[Ntot-1]+betaD*(-1./(3.*dx*hj[Ntot-1])*(hiN**3*DxuiN-hi[Ntot-2]**3*Dxui[Ntot-2])-alfa/dx*fj[Ntot-1]**2*(DxuiN-Dxui[Ntot-2]))  #Boundary node
    
    #-    
    # Pentadiagonal sparse matrix to estimate pointwise cell face values
    #-
    Ajtot = VolIntMat(Ntot)

    #-
    # Cell face values q at j nodes
    #-
    qj = (spsolve( Ajtot, Qj.T ) ).T

    #-
    # Cell face values q at i nodes
    #-
    qi1   = 1./16.*( 5.*qj[0     ] + 15*qj[1     ] - 5.*qj[2     ] + 1*qj[3     ] )
    qiNm1 = 1./16.*( 5.*qj[Ntot-1] + 15*qj[Ntot-2] - 5.*qj[Ntot-3] + 1*qj[Ntot-4] )
    qi    = CellFaceInt( dx, Qj[1:Ntot - 1], ADi, qi1, qiNm1)

    #-
    # Cell averaged values for water depth
    #-
    Hi0 = 2./3.*hi[0:Ntot-1] + 1./6.*( hj[0:Ntot-1]+hj[1:Ntot] )
    
    #-
    # Cell averaged values for q
    #-
    Qi0 = 2./3.*qi[0:Ntot-1] + 1./6.*( qj[0:Ntot-1]+qj[1:Ntot] )
    
    
    # ----------------------------------------------------------------------------------------------------
    # -------------------------------- Numerical Integration ---------------------------------------------
    # --------------------- 4th order finite volume discretization for -----------------------------------
    # ------------------- spatial domain and 4th order Runge-Kutta method --------------------------------
    # ------------------------- for time integration (method of lines) -----------------------------------
    # ----------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Matrix reduction -------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
#RB verifier ici 
#verifier valeur Next
    ADxjr  = Comp_1st_Mat( Next+1 )    
    ADxir  = Comp_1st_Mat( Next)    
    ADxxjr = Comp_2nd_Mat( Next+1 )    
    ADr = Comp_1st_Mat( Next-1 )    
    BQr = Cell_J_Mat( Next+1 )
    Nu1j = np.zeros( Ntot )
    Nu2j = np.zeros( Ntot )
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Derivative estimates ---------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-        
    Dxhj  = Deriv1j( hj[0:Next+1], dx,ADxjr  )
    Dxxhj = Deriv2j( hj[0:Next+1], dx,ADxxjr )
    Dxuj  = Deriv1j( uj[0:Next+1], dx,ADxjr  )
    Dxxuj = Deriv2j( uj[0:Next+1], dx,ADxxjr )
    
    # ----------------------------------------------------------------------------------------------------
    # -------------------------------- Variable initialization -------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    Nu1j = np.zeros( Ntot )    
    Nu2j = np.zeros( Ntot )    
    kBrWave = []    
    t = t0    
    etamj = np.zeros(Ntot)
    
    Hi  = Hi0
    hj0 = hj
    hi0 = hi
    uj0 = uj
    xb = 0
    varFa = 0
    kst = 0
    hout = h0
    i = 0

    Time     = np.zeros( Tf+1 )    
    hLeft    = np.zeros( Tf+1 )    
    uLeft    = np.zeros( Tf+1 )    
    hRight   = np.zeros( Tf+1 )    
    uRight   = np.zeros( Tf+1 )    
    WaterVol = np.zeros( Tf+1 )    
    VolIn    = np.zeros( Tf+1 )    

    Hi= np.zeros(Ntot-1)   
    Qi= np.zeros(Ntot-1)   

    if (1==1):
        Time[i] = t
        hLeft[i]  = hj[0]
        uLeft[i]  = uj[0]
        hRight[i] = hj[N-1]
        uRight[i] = uj[N-1]
        WaterVol[i] = dx*np.sum( Hi[0:N-1] )
        VolIn[i] = dt*hLeft[i]*uLeft[i]
        i = i + 1

        # ------------------------------------------------------------------------------------------------
        # ------------------------------ First Runge-Kutta stage -----------------------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        jc,jt,MatWav = WaveProp( Xj[0:N], hj[0:N], fj[0:N], Dxhj[0:N], Dxfj[0:N], WDtol, nargout=3 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex( t, kTb, PHIb, PHIf, hj[0:N], uj[0:N], fj[0:N], MatWav, kBrWave, dx, dt, g, WDtol )

        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity( t, PHI1, PHI2, bCointe, alfab, alfaf, gamab, gamaf, kap1, kap2, kBrWave, Xj[0:N], hj[0:N], fj[0:N], dx, g, WDtol, nargout=3 )
        Nu1j = np.concatenate( [ Nu1j[0:N], np.zeros(Ntot - N ) ] )
        Nu2j = np.concatenate( [ Nu2j[0:N], np.zeros(Ntot - N ) ] )

        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity( hj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], Nu1j[0:N+1] )
        FCi = 1./dx*( FCj[1:N+1] - FCj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj = FluxMomentum( qj[0:N+1], hj[0:N+1], fj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], Dxuj[0:N+1], Dxxhj[0:N+1], Dxxuj[0:N+1], Dxxfj[0:N+1], g, betaD, alfa, WDtol)
        FMi = 1./dx*( FMj[1:N+1] - FMj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi = SourceMomentum( hi[0:N],hj[0:N+1],fi[0:N],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxfi[0:N],Dxuj[0:N+1],Nu2j[0:N+1],Xi[0:N],g,betaD,alfa,fricFact,Cfi[0:N],WDtol)
        SMi = 1./dx*SMi
        DtHi = -FCi
        DtQi = -FMi + SMi


        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Estimates of Hi and Qi at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH1 = dt*DtHi
        kQ1 = dt*DtQi
        Hi[0:N] = Hi0[0:N] + 1./2.*kH1
        Qi[0:N] = Qi0[0:N] + 1./2.*kQ1
        if FilterD1 == 1:
            Hi[N-NIZ:N] = explicitFILT0( Hi[N-NIZ:N] )
            Qi[N-NIZ:N] = explicitFILT0( Qi[N-NIZ:N] )
        
        #-            
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*(Hi[N-1] - Hi[N-2])
        dq = 1./dx*(Qi[N-1] - Qi[N-2])
        Hi[N:Ntot] = Hi[N-1] + dh*(Xi[N:Ntot] - Xi[N-1])
        Qi[N:Ntot] = Qi[N-1] + dq*(Xi[N:Ntot] - Xi[N-1])

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Cell faces values hj, qj and uj at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        
        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt/2 (explicit stage)
        # ------------------------------------------------------------------------------------------------
        #-
        
        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-

#RB
#RB Verif
        data=(dx,dt/2.,uj0,hj0,g)
        beta = fsolve (findposRL1, Cr,  args=data )


        p = floor(beta)
        b = beta - p
        p = int(p)
        uR0 = (1-b)*uj0[p]+b*uj0[p+1];
        hR0 = (1-b)*hj0[p]+b*hj0[p+1];    
        DxfR0 = (1-b)*Dxfj[p]+b*Dxfj[p+1];
     
        #Water depth and velocity for incident wave
        hL0 = DataManip(t+dt/2.,h0+offset,DAT)
        uL0 = (g*hL0)**0.5*(hL0+fj[0])/hL0
        
        IR=uR0 -2*(g*hR0)**0.5 - dt/2.*g*DxfR0 # Variable de Riemann associee a C-

        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + 2.*(g*hL0) ** 0.5   #- dot(dot(dot(0,dt)/2.,g),Dxfj(1))

        #-
        # Boundary values for water depth and depth-averaged velocity at t=t+dt/2
        #-        
        uA = 1./2.*(IL + IR)
        hA = 1./(16.*g)*(IL - IR)**2
        
        #-
        # Cell face values reconstruction for water depth h
        #-
        hj = CellFaceInt( dx, Hi[0:Next], ADr, hA )
        Dxhj  = Deriv1j( hj[0:Next+1], dx, ADxjr  )
        Dxxhj = Deriv2j( hj[0:Next+1], dx, ADxxjr )

        hi = 3./2.*Hi[0:Next] - 1./4.*(hj[0:Next] + hj[1:Next+1])
        uj, qj = DeffCorrU(uA,Qi[0:Next],hi[0:Next],hj[0:Next+1],fj[0:Next+1],Dxhj[0:Next+1],Dxfj[0:Next+1],Dxxfj[0:Next+1],dx,ADr,BQr,uj[0:Next+1],betaD,alfa,tol,MaxIter,WDtol,nargout=2)
        Dxuj = Deriv1j(uj[0:Next+1],dx,ADxjr)
        Dxxuj= Deriv2j(uj[0:Next+1],dx,ADxxjr)


        # ------------------------------------------------------------------------------------------------
        # ----------------------------- Second Runge-Kutta stage -----------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
    

        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        jc, jt, MatWav = WaveProp(Xj[0:N+1],hj[0:N+1],fj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],WDtol,nargout=3)

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex(t,kTb,PHIb,PHIf,hj[0:N+1],uj[0:N+1],fj[0:N+1],MatWav,kBrWave,dx,dt,g,WDtol)

        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity(t,PHI1,PHI2,bCointe,alfab,alfaf,gamab,gamaf,kap1,kap2,kBrWave,Xj[0:N+1],hj[0:N+1],fj[0:N+1],dx,g,WDtol,nargout=3)
        Nu1j = np.concatenate( [ Nu1j[0:N], np.zeros(Ntot - N ) ] )
        Nu2j = np.concatenate( [ Nu2j[0:N], np.zeros(Ntot - N ) ] )

        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity(hj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Nu1j[0:N+1])
        FCi = 1./dx*( FCj[1:N+1] - FCj[0:N] )
        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj = FluxMomentum( qj[0:N+1],hj[0:N+1],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxuj[0:N+1],Dxxhj[0:N+1],Dxxuj[0:N+1],Dxxfj[0:N+1],g,betaD,alfa,WDtol)
        FMi = 1./dx*( FMj[1:N+1] - FMj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi = SourceMomentum( hi[0:N],hj[0:N+1],fi[0:N],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxfi[0:N],Dxuj[0:N+1],Nu2j[0:N+1],Xi[0:N],g,betaD,alfa,fricFact,Cfi[0:N],WDtol)
        SMi = 1./dx*SMi
        DtHi = -FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Estimates of Hi and Qi at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH2 = dt*DtHi
        kQ2 = dt*DtQi
        Hi[0:N] = Hi0[0:N] + 1./2.*kH2
        Qi[0:N] = Qi0[0:N] + 1./2.*kQ2
        if FilterD1 == 1:
            Hi[N-NIZ:N] = explicitFILT0( Hi[N-NIZ:N] )
            Qi[N-NIZ:N] = explicitFILT0( Qi[N-NIZ:N] )

        #-            
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*(Hi[N-1] - Hi[N-2])
        dq = 1./dx*(Qi[N-1] - Qi[N-2])
        Hi[N:Ntot] = Hi[N-1] + dh*(Xi[N:Ntot] - Xi[N-1])
        Qi[N:Ntot] = Qi[N-1] + dq*(Xi[N:Ntot] - Xi[N-1])


        # ------------------------------------------------------------------------------------------------
        # ----------------------------------- Finding last wet cell --------------------------------------
        # ------------------------------------------------------------------------------------------------
        #-        
        N1 = np.max(np.where(hj > WDtol))
        N2 = np.min(np.where(hj < WDtol))
        Nm = min(N1,N2)
#RB
        if ( Nm.size > 0) and Nm != N and Nm < (Ntot - NSZ):
            if Nm > N:
                set_interp = interp1d( Xi[0:N], kH1[0:N], kind='linear', fill_value='extrapolate' )
                toto = set_interp(Xi[N:Nm])
                kH1 = np.concatenate([kH1[0:N],toto ])

                set_interp = interp1d( Xi[0:N], kH2[0:N], kind='linear', fill_value='extrapolate' )
                toto = set_interp(Xi[N:Nm])
                kH2 = np.concatenate([kH2[0:N],toto ])

                set_interp = interp1d( Xi[0:N], kQ1[0:N], kind='linear', fill_value='extrapolate' )
                toto = set_interp(Xi[N:Nm])
                kQ1 = np.concatenate([kQ1[0:N],toto ])

                set_interp = interp1d( Xi[0:N], kQ2[0:N], kind='linear', fill_value='extrapolate' )
                toto = set_interp(Xi[N:Nm])
                kQ2 = np.concatenate([kQ2[0:N],toto ])

                set_interp = interp1d( Xj[0:N+1], etamj[0:N+1], kind='linear', fill_value='extrapolate' )
                toto = set_interp(Xj[N+1:Nm+1])                
                etamj = np.concatenate([etamj[0:N],toto ])
            N = Nm
            Next = N + NSZ
            Nint = N - NSZ

            #-
            # Matrix reduction
            #-
            ADxjr  = Comp_1st_Mat( Next+1 )    
            ADxir  = Comp_1st_Mat( Next)    
            ADxxjr = Comp_2nd_Mat( Next+1 )    
            ADr = Comp_1st_Mat( Next-1 )    
            BQr = Cell_J_Mat( Next+1 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Cell faces values hj, qj and uj at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt/2 (implicit stage)
        # ------------------------------------------------------------------------------------------------
        #-

        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-
        
        data=(dx,dt/2,uj0,hj0,hj[0],uj[0],g)
        beta = fsolve (findposRL2, Cr,  args=data ) 
        
        p = floor(beta)
        b = beta - p
        p = int(p)
        uR0 = (1-b)*uj0[p]+b*uj0[p+1];
        hR0 = (1-b)*hj0[p]+b*hj0[p+1];    
        DxfR0 = (1-b)*Dxfj[p]+b*Dxfj[p+1];
     
        #Water depth and velocity for incident wave
        hL0 = DataManip(t+dt/2.,h0+offset,DAT)
        uL0 = (g*hL0)**0.5*(hL0+fj[0])/hL0
   
        IR=uR0 -2*(g*hR0)**0.5 - dt/2.*g*DxfR0 # Variable de Riemann associee a C-
     
        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + 2.*(g*hL0) ** 0.5   #- dot(dot(dot(0,dt)/2.,g),Dxfj(1))
        
        #-
        # Boundary values for water depth and depth-averaged velocity at t=t+dt/2
        #-
        uA = 1./2.*(IL + IR)
        hA = 1./(16.*g)*(IL - IR)**2

        # Cell face values reconstruction for water depth h
        hj = CellFaceInt( dx, Hi[0:Next], ADr, hA )
        Dxhj  = Deriv1j( hj[0:Next+1], dx, ADxjr  )
        Dxxhj = Deriv2j( hj[0:Next+1], dx, ADxxjr )

        hi = 3./2.*Hi[0:Next] - 1./4.*(hj[0:Next] + hj[1:Next+1])

        if Next > len(uj):
            Nu = len(uj)
            du = 1. / dx*(uj[Nu]-uj[Nu-1])
            uj[Nu+1:Next+1] = du*( Xj[Nu+1:Next] - Xj[Next] )
            if FilterD1 == 1:
                uj[Nu-NIZ:Next+1]=explicitFILT0(uj[Nu -NIZ,Next+1])
        
        uj, qj = DeffCorrU(uA, Qi[0:Next], hi[0:Next], hj[0:Next+1], fj[0:Next+1], Dxhj[0:Next+1], Dxfj[0:Next+1], Dxxfj[0:Next+1], dx, ADr, BQr, uj[0:Next+1], betaD, alfa, tol, MaxIter, WDtol);
        Dxuj = Deriv1j( uj[0:Next+1], dx, ADxjr  )
        Dxxuj= Deriv2j( uj[0:Next+1], dx, ADxxjr )
        
        hj0 = hj
        hi0 = hi
        uj0 = uj

         # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ------------------------------ Third Runge-Kutta stage -----------------------------------------
    
        # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        #-
        jc,jt,MatWav = WaveProp( Xj[0:N+1], hj[0:N+1],fj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], WDtol, nargout=3 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex( t, kTb, PHIb, PHIf, hj[0:N+1], uj[0:N+1], fj[0:N+1], MatWav, kBrWave, dx, dt, g, WDtol)
        
        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity(t, PHI1, PHI2, bCointe, alfab, alfaf, gamab, gamaf, kap1, kap2, kBrWave, Xj[0:N+1], hj[0:N+1],fj[0:N+1], dx, g, WDtol, nargout=3)
        Nu1j = np.concatenate( [ Nu1j[0:N], np.zeros(Ntot - N ) ] )
        Nu2j = np.concatenate( [ Nu2j[0:N], np.zeros(Ntot - N ) ] )
        
        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity( hj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], Nu1j[0:N+1] )
        FCi = 1./dx*( FCj[1:N+1] - FCj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj=FluxMomentum(qj[0:N+1], hj[0:N+1],fj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1],Dxuj[0:N+1], Dxxhj[0:N+1], Dxxuj[0:N+1], Dxxfj[0:N+1], g, betaD, alfa, WDtol)
        FMi = 1./dx*( FMj[1:N+1] - FMj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi=SourceMomentum(hi[0:N],hj[0:N+1],fi[0:N],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxfi[0:N],Dxuj[0:N+1],Nu2j[0:N+1],Xi[0:N],g,betaD,alfa,fricFact,Cfi[0:N],WDtol)
        SMi = 1./dx*SMi
        DtHi = - FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # --------------------------------- Estimates of Hi and Qi at t=t+dt -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH3 = dt*DtHi
        kQ3 = dt*DtQi
        Hi[0:N] = Hi0[0:N] + 1./2.*kH3
        Qi[0:N] = Qi0[0:N] + 1./2.*kQ3
        if FilterD1 == 1:
            Hi[N-NIZ:N] = explicitFILT0( Hi[N-NIZ:N] )
            Qi[N-NIZ:N] = explicitFILT0( Qi[N-NIZ:N] )
        
        #-            
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*(Hi[N-1] - Hi[N-2])
        dq = 1./dx*(Qi[N-1] - Qi[N-2])
        Hi[N:Ntot] = Hi[N-1] + dh*(Xi[N:Ntot] - Xi[N-1])
        Qi[N:Ntot] = Qi[N-1] + dq*(Xi[N:Ntot] - Xi[N-1])

        # ------------------------------------------------------------------------------------------------
        # ------------------------ Cell faces values hj, qj and uj at t=t+dt -----------------------------
        # ------------------------------------------------------------------------------------------------
        
        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt (explicit stage)
        # ------------------------------------------------------------------------------------------------
        #
        
        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-
        data=(dx,dt/2.,uj0,hj0,g)
        beta = fsolve (findposRL1, Cr,  args=data ) 
       

