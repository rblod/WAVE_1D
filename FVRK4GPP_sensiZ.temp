import numpy as np
from scipy.interpolate   import interp1d
from scipy.sparse.linalg import spsolve
from scipy.optimize import fsolve, root
from math  import pi

from explicitFILT0 import *
from InterpItoJ    import *
from jonswap_blw   import *
from Comp_1st_Mat  import *
from Cell_J_Mat    import *
from Deriv1j       import *
from deriv1i       import *
from Comp_2nd_Mat  import *
from Deriv2j       import *
from opfiles       import *
from VolIntMat     import *
from CellFaceInt   import *
from WaveProp      import * 
from BrWaveIndex   import *
from EddyViscosity import *
from FluxContinuity import *
from FluxMomentum   import * 
from SourceMomentum import *
from DataManip      import *
from findposRL1 import *
from findposRL2 import *
from DeffCorrU  import *

def FVRK4GPP_sensiZ(Ti=None, Tf=None, Cr=None, STO=None, carpetaN=None, carpetaO=None, RootFolder=None,*args,**kwargs):
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------------- Main Routine -----------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    # Method :
    # Numerical Method solving the Serre Equations for uneven bottoms
    # 4th order finite volume for spatial discretization
    # 4th order Runge-Kutta method for time stepping
    # Modified equations from Seabra-Santos et al. (1987)
    # Retaining terms of order O(sigma^2) and Pade [2,2] linear dispersion correction based on Madsen et al. (1991)
    #-
    # History
    # 4/02/2019 : Rachid Benshila LEGOS-CNRS    , Python version 
    # 4/01/2010 : Rodrigo Cienfuegos C. LEGI-PUC, Initial version
    # ----------------------------------------------------------------------------------------------------
    
#RB  lastwarn('')
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Problem definition and parameters -------------------------------------
    # ----------------------------------------------------------------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # Downward gravitational acceleration (m\s^2)
    # ----------------------------------------------------------------------------------------------------
    #-
    g = 9.81

    # ----------------------------------------------------------------------------------------------------
    #-
    Zprof = np.load( RootFolder+'/Zprof.npy' )

    # ----------------------------------------------------------------------------------------------------
    #
# Incident wave field
#Profondeur d'eau au large
    h0 = abs(Zprof[0])
    H0 = 0.5    
    a0 = H0/.2
    T0 = 10
    
    c0 = (g*h0)** 0.5    
    L0 = c0*T0    
    k0 = 2*pi/L0    
    epsilon = a0/h0    
    kh0 = k0*h0    
    offset = 0
        
    # ----------------------------------------------------------------------------------------------------
    # Wave breaking parametrization
    # ----------------------------------------------------------------------------------------------------
    #-
    PHIb = 28.*pi / 180.    
    PHIf =  8.*pi / 180.    
    PHI1 = 13.*pi / 180.    
    PHI2 = 13.*pi / 180.    
    gamab = 0.8    
    gamaf = 0.8   
    kap1 = 0.1    
    kap2 = 0.1    
    alfab = 5.0    
    alfaf = 5.0   
    kTb = 5.0    
    bCointe = 0.796
        
    # ----------------------------------------------------------------------------------------------------
    # Numerical discretization
    # ----------------------------------------------------------------------------------------------------
    #-
    ro = 0.1    
    dx = ro*h0    
    dt = Cr/(g*h0)**0.5*dx    
    WDtol = 0.0001
        
    # ----------------------------------------------------------------------------------------------------
    # Linear dispersion correction (Madsen et al., 1991)
    # ----------------------------------------------------------------------------------------------------
    #-
    alfa = 1./15.
        
    # ----------------------------------------------------------------------------------------------------
    # Friction coefficient
    # ----------------------------------------------------------------------------------------------------
    #-
    fricFact = 0    
    Cf = 0.015
    
    
    # ----------------------------------------------------------------------------------------------------
    # Filtering Wet domain
    # ----------------------------------------------------------------------------------------------------
    #-
    FilterD1 = 1   
    FilterD2 = 1  
    NSZ = 15    
    NIZ = 15    
    NFT = 0    
    alfaF = 0.4
    
    # ----------------------------------------------------------------------------------------------------
    # Parameter values for Picard iterations in deferred-correction approach
    # ----------------------------------------------------------------------------------------------------
    #-
    MaxIter = 10    
    tol = 1e-05
    
    # ----------------------------------------------------------------------------------------------------
    # Dispersion terms (betaD=1 : Activate dispersif terms ; betaD=0 : Neglect dispersif terms)
    # ----------------------------------------------------------------------------------------------------
    #-
    betaD = 1

    # ----------------------------------------------------------------------------------------------------
    # Bottom bathymetry and physical domain (wet & dry)
    # ----------------------------------------------------------------------------------------------------
    #-
    slope = 0.02
    
    xf = np.arange( 1, len(Zprof)+1 )
    zf = Zprof
    zf[0:3] = zf[0]

    Xlong=max(xf)+dx    
    Xj = np.arange( xf[0], Xlong, dx )    
    Xi = np.arange( xf[0] + dx/2., Xlong-dx/2., dx )
    
    set_interp = interp1d( xf, zf, kind='linear', fill_value='extrapolate' )
    fi = set_interp( Xi )
    fi = explicitFILT0( fi )

    set_interp = interp1d( Xi, fi, kind='linear', fill_value='extrapolate' )
    fj = set_interp( Xj[len(Xj)-1] )  
    fj = InterpItoJ( fi, zf[0], fj )
    
    Ntot=len(Xj)
    
    N=min( np.min( np.where(fj > 0) ), np.max( np.where(fj <= 0) ) )
    
    Next=N + NSZ
    
    Nint=N - NIZ
    
    # ----------------------------------------------------------------------------------------------------
    # Wave forcing
    # ----------------------------------------------------------------------------------------------------
    #-
    
    # load([RootFolder,'/serie_temp_jonswap_sensi_terrasse_slope']);
# ii=find(etahf(1:end-1)<=0&etahf(2:end)>0);
# etahf=etahf(ii(1):end);tti=tti(ii(1):end);tti=tti-min(tti);
    
    Tp1 = 10
    a1 = 0.5
    dt = 0.01
    ff,SSm,tt,etahf,eta,etaLB = jonswap_blw( 1000, int(1./dt), 1./Tp1, a1, 100, 3, 3, 3, nargout=6 )
 
    DAT = np.zeros( [len(tt), 2] )
    DAT[:,0] = tt
    DAT[:,1] = etahf
    Cfi = Cf*np.ones( [Ntot] )
        
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Output files with results and parameters ------------------------------ 
    # ----------------------------------------------------------------------------------------------------
    #-
    # Rows = spatial coordinate
    # Columns = temporal coordinate
    #-
    fidParam,fidXj,fidXi,fidFj,fidFxj,fidFxxj,fidHj,fidHi,fidUj,fidUi,fidUxj,fidUxxj,fidNUj,fidTime,fidNwet,fidXb,fidHout=opfiles(carpetaN,RootFolder,nargout=17)
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Constant Matrix Generation ---------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    ADxj  = Comp_1st_Mat( Ntot   )    
    ADxi  = Comp_1st_Mat( Ntot-1 )     
    ADxxj = Comp_2nd_Mat( Ntot   )    
    AD  = Comp_1st_Mat( Ntot-2 )    
    ADi = Comp_1st_Mat( Ntot-3 )    
    BQ = Cell_J_Mat( Ntot )
    
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------- Bottom's derivative estimate ------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    Dxfj=Deriv1j(fj,dx,ADxj)
    Dxfi=deriv1i(fi,fj[0],fj[Ntot-1],dx,ADxi)
    Dxxfj=Deriv2j(fj,dx,ADxxj)

    #    fidXj.write('%6.4f \\t' % elem for elem in Xj)
    #    fidXi.write('%6.4f \\t',Xi)
    #    fidFj.write('%6.4f \\t',fj)
    #    fidFxj.write('%6.4f \\t',Dxfj)
    #    fidFxxj.write('%6.4f \\t',Dxxfj)

    np.savetxt( carpetaN+'/Xj.dat'  , Xj   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Xi.dat'  , Xi   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fj.dat'  , fj   ,   fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fxj.dat' , Dxfj ,  fmt='%6.4f', delimiter='\t' )
    np.savetxt( carpetaN+'/Fxxj.dat', Dxxfj, fmt='%6.4f', delimiter='\t' )
    
    # ----------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    # ---------------------------------- Initial Conditions ----------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # Initial conditions for water depth h and depth-averaged velocity u at cell faces (j nodes)
    # ----------------------------------------------------------------------------------------------------
    #-
    t0 = Ti
    
    
    if t0 == 0:
        hj = -fj[0:Ntot]
        uj = np.zeros( [Ntot] )
        hi = -fi[0:Ntot-1]
        set_interp = interp1d( Xj, uj, kind='cubic' )
        ui = set_interp(Xi)
        qj = np.zeros( [Ntot] )
    else:
        hj, uj, hi, ui, t0 = readLastLine( carpetaO, RootFolder, nargout=5 )
        
    # ----------------------------------------------------------------------------------------------------
    # Initial condition for auxiliary variable q at cell faces (j nodes)
    # ----------------------------------------------------------------------------------------------------
    #- 

    #-   
    # Cell-averaged values for depth-averaged velocity at j cells
    #-
    Uj = np.zeros([Ntot])
    Uj[0]=2./3.*uj[0] + 1./6.*( 5*ui[0] - 6.*ui[1] + 4.*ui[2] - ui[3])    
    Uj[1:Ntot-1]=2./3.*uj[1:Ntot-1] + 1./6.*( ui[0:Ntot - 2] + ui[1:Ntot - 1])    
    Uj[Ntot-1]=2./3.*uj[Ntot-1] + 1./6.*(5.*ui[Ntot-2] - 6*ui[Ntot-3] + 4.*ui[Ntot-4] - ui[Ntot-5])
    
    Dxui=deriv1i(ui,uj[0],uj[Ntot-1],dx,ADxi)    
    Dxhj=Deriv1j(hj,dx,ADxj)
    
    rj=betaD*((Dxhj[0:Ntot]+Dxfj[0:Ntot])*Dxfj[0:Ntot]+1./2.*hj[0:Ntot]*Dxxfj[0:Ntot])  # Auxiliary variable r at j nodes
    hi0   = 4.*hi[0]  -6.*hi [1]+4.*hi  [2]-  hi[3]                              # cubic extrapolation
    Dxui0 = 4.*Dxui[0]-6*Dxui[1]+4.*Dxui[2]-Dxui[3]                              # cubic extrapolation
    hiN   = 4.*hi  [Ntot-2]-6*hi  [Ntot-3]+4.*hi  [Ntot-4]-hi  [Ntot-5]          # cubic extrapolation
    DxuiN = 4.*Dxui[Ntot-2]-6*Dxui[Ntot-3]+4.*Dxui[Ntot-4]-Dxui[Ntot-5]          # cubic extrapolation
    
    #-
    # Cell-averaged values for auxiliary variable q at j cells
    #- 
    Qj = np.zeros( [Ntot] )
    Qj[0       ] = (1+rj[0])*Uj[0]+betaD*np.array([-1./(3.*dx*hj[0])*(hi[0]**3*Dxui[0]-hi0**3*Dxui0)-alfa/dx*fj[0]**2*(Dxui[0]-Dxui0)]) # Boundary node
    Qj[1:Ntot-1] = (1+rj[1:Ntot-1])*Uj[1:Ntot-1]+betaD*(-1./(3.*dx*hj[1:Ntot-1])*(hi[1:Ntot-1]**3*Dxui[1:Ntot-1]-hi[0:Ntot-2]**3*Dxui[0:Ntot-2])-alfa/dx*fj[1:Ntot-1]**2*(Dxui[1:Ntot-1]-Dxui[0:Ntot-2]))#Internal nodes
    Qj[Ntot-1  ] = (1+rj[Ntot-1])*Uj[Ntot-1]+betaD*(-1./(3.*dx*hj[Ntot-1])*(hiN**3*DxuiN-hi[Ntot-2]**3*Dxui[Ntot-2])-alfa/dx*fj[Ntot-1]**2*(DxuiN-Dxui[Ntot-2]))  #Boundary node
    
    #-    
    # Pentadiagonal sparse matrix to estimate pointwise cell face values
    #-
    Ajtot = VolIntMat(Ntot)

    #-
    # Cell face values q at j nodes
    #-
    qj = (spsolve( Ajtot, Qj.T ) ).T

    #-
    # Cell face values q at i nodes
    #-
    qi1   = 1./16.*( 5.*qj[0     ] + 15*qj[1     ] - 5.*qj[2     ] + 1*qj[3     ] )
    qiNm1 = 1./16.*( 5.*qj[Ntot-1] + 15*qj[Ntot-2] - 5.*qj[Ntot-3] + 1*qj[Ntot-4] )
    qi    = CellFaceInt( dx, Qj[1:Ntot - 1], ADi, qi1, qiNm1)

    #-
    # Cell averaged values for water depth
    #-
    Hi0 = 2./3.*hi[0:Ntot-1] + 1./6.*( hj[0:Ntot-1]+hj[1:Ntot] )
    
    #-
    # Cell averaged values for q
    #-
    Qi0 = 2./3.*qi[0:Ntot-1] + 1./6.*( qj[0:Ntot-1]+qj[1:Ntot] )
    
    
    # ----------------------------------------------------------------------------------------------------
    # -------------------------------- Numerical Integration ---------------------------------------------
    # --------------------- 4th order finite volume discretization for -----------------------------------
    # ------------------- spatial domain and 4th order Runge-Kutta method --------------------------------
    # ------------------------- for time integration (method of lines) -----------------------------------
    # ----------------------------------------------------------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Matrix reduction -------------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
#RB verifier ici 
#verifier valeur Next
    ADxjr  = Comp_1st_Mat( Next+1 )    
    ADxir  = Comp_1st_Mat( Next)    
    ADxxjr = Comp_2nd_Mat( Next+1 )    
    ADr = Comp_1st_Mat( Next-1 )    
    BQr = Cell_J_Mat( Next+1 )
    Nu1j = np.zeros( Ntot )
    Nu2j = np.zeros( Ntot )
    
    # ----------------------------------------------------------------------------------------------------
    # --------------------------------- Derivative estimates ---------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-        
    Dxhj  = Deriv1j( hj[0:Next+1], dx,ADxjr  )
    Dxxhj = Deriv2j( hj[0:Next+1], dx,ADxxjr )
    Dxuj  = Deriv1j( uj[0:Next+1], dx,ADxjr  )
    Dxxuj = Deriv2j( uj[0:Next+1], dx,ADxxjr )
    
    # ----------------------------------------------------------------------------------------------------
    # -------------------------------- Variable initialization -------------------------------------------
    # ----------------------------------------------------------------------------------------------------
    #-
    Nu1j = np.zeros( Ntot )    
    Nu2j = np.zeros( Ntot )    
    kBrWave = []    
    t = t0    
    etamj = np.zeros(Ntot)
    
    Hi  = Hi0
    hj0 = hj
    hi0 = hi
    uj0 = uj
    xb = 0
    varFa = 0
    kst = 0
    hout = h0
    i = 0

    Time     = np.zeros( Tf+1 )    
    hLeft    = np.zeros( Tf+1 )    
    uLeft    = np.zeros( Tf+1 )    
    hRight   = np.zeros( Tf+1 )    
    uRight   = np.zeros( Tf+1 )    
    WaterVol = np.zeros( Tf+1 )    
    VolIn    = np.zeros( Tf+1 ) 

    Hi= np.zeros(Ntot-1)   
    Qi= np.zeros(Ntot-1)   
   
    while t <= (Tf + dt):

        # ------------------------------------------------------------------------------------------------
        # --------------- Storing time, boundary conditions and total water volume in the domain ---------
        # ------------------------------------------------------------------------------------------------
        #-
        Time[i] = t
        hLeft[i]  = hj[0]
        uLeft[i]  = uj[0]
        hRight[i] = hj[N-1]
        uRight[i] = uj[N-1]
        WaterVol[i] = dx*np.sum( Hi[0:N-1] )
        VolIn[i] = dt*hLeft[i]*uLeft[i]
        i = i + 1
        
        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Storing computation data ---------------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        vv = kst / STO
        if ( vv == 1 or t == 0 ):

            set_interp = interp1d( Xj[Next-10:Next+1],  hj[Next-10:Next+1], kind='linear', fill_value='extrapolate' )
            Hw = np.concatenate( [ hj[0:Next], set_interp( Xj[Next+1:Ntot] ) ] ) 
            set_interp = interp1d( Xi[Next-11:Next],  hi[Next-11:Next], kind='linear', fill_value='extrapolate' )
            Hwi = np.concatenate( [ hj[0:Next-1], set_interp( Xi[Next:Ntot-1] ) ] ) 
            set_interp = interp1d( Xj[Next-10:Next+1],  uj[Next-10:Next+1], kind='linear', fill_value='extrapolate' )
            Uw = np.concatenate( [ uj[0:Next], set_interp( Xj[Next+1:Ntot] ) ] ) 
            Uxw  = np.concatenate( [ Dxuj [0:Next], np.zeros(Ntot - Next-1) ] )
            Uxxw = np.concatenate( [ Dxxuj[0:Next], np.zeros(Ntot - Next-1) ] )
            NU1w = np.concatenate( [ Nu2j[0:Next] , np.zeros(Ntot - Next-1) ] )
            fprintf(fidHj,'%6.8f \\t',Hw)
            fprintf(fidHj,'\\n')
            fprintf(fidHi,'%6.8f \\t',Hwi)
            fprintf(fidHi,'\\n')
            fprintf(fidUj,'%6.8f \\t',Uw)
            fprintf(fidUj,'\\n')
            fprintf(fidUxj,'%6.8f \\t',Uxw)
            fprintf(fidUxj,'\\n')
            fprintf(fidUxxj,'%6.8f \\t',Uxw)
            fprintf(fidUxxj,'\\n')
            fprintf(fidNUj,'%6.8f \\t',NU1w)
            fprintf(fidNUj,'\\n')
            fprintf(fidTime,'%6.4f \\t',t)
            fprintf(fidTime,'\\n')
            fprintf(fidNwet,'%6.4f \\t',N)
            fprintf(fidNwet,'\\n')
            fprintf(fidXb,'%6.4f \\t',xb)
            fprintf(fidXb,'\\n')
            fprintf(fidHout,'%6.4f \\t',hout)
            fprintf(fidHout,'\\n')
            kst = - 1
        kst = kst + 1
        # ------------------------------------------------------------------------------------------------
        # --------------------------------- Screen Information -------------------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
#RB    clc
        print('%s %6.3f %s \\t','Current time = ',t,'s')
        print('%s %6.3f %s \\t','dx = ',dx,'m')
        print('%s %6.3f %s \\t','dt = ',dt,'s')
        print('%s %6.0f \\n\\n','N = ',N)
        print('%s %6.3f %s \\n','Breaking point x-coordinate xb = ',xb,'m')
        print( '%s %6.3f %s \\n'   , 'Volume of water in the domain V/V0         = ', 100*WaterVol[i-1] / WaterVol[0], '%' )
        print(' %s %6.3f %s \\n\\n', 'Volume of water entering the domain Vin/V0 = ', 100*VolIn   [i-1] / WaterVol[0], '%' )

        # ------------------------------------------------------------------------------------------------
        # ------------------------------ First Runge-Kutta stage -----------------------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        jc,jt,MatWav = WaveProp( Xj[0:N], hj[0:N], fj[0:N], Dxhj[0:N], Dxfj[0:N], WDtol, nargout=3 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex( t, kTb, PHIb, PHIf, hj[0:N], uj[0:N], fj[0:N], MatWav, kBrWave, dx, dt, g, WDtol )

        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity( t, PHI1, PHI2, bCointe, alfab, alfaf, gamab, gamaf, kap1, kap2, kBrWave, Xj[0:N], hj[0:N], fj[0:N], dx, g, WDtol, nargout=3 )
        Nu1j = np.concatenate( [ Nu1j[0:N], np.zeros(Ntot - N ) ] )
        Nu2j = np.concatenate( [ Nu2j[0:N], np.zeros(Ntot - N ) ] )

        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity( hj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], Nu1j[0:N+1] )
        FCi = 1./dx*( FCj[1:N+1] - FCj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj = FluxMomentum( qj[0:N+1], hj[0:N+1], fj[0:N+1], uj[0:N+1], Dxhj[0:N+1], Dxfj[0:N+1], Dxuj[0:N+1], Dxxhj[0:N+1], Dxxuj[0:N+1], Dxxfj[0:N+1], g, betaD, alfa, WDtol)
        FMi = 1./dx*( FMj[1:N+1] - FMj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi = SourceMomentum( hi[0:N],hj[0:N+1],fi[0:N],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxfi[0:N],Dxuj[0:N+1],Nu2j[0:N+1],Xi[0:N],g,betaD,alfa,fricFact,Cfi[0:N],WDtol)
        SMi = 1./dx*SMi
        DtHi = -FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Estimates of Hi and Qi at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH1 = dt*DtHi
        kQ1 = dt*DtQi
        Hi[0:N] = Hi0[0:N] + 1./2.*kH1
        Qi[0:N] = Qi0[0:N] + 1./2.*kQ1
        if FilterD1 == 1:
            Hi[N-NIZ:N] = explicitFILT0( Hi[N-NIZ:N] )
            Qi[N-NIZ:N] = explicitFILT0( Qi[N-NIZ:N] )
        
        #-            
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*(Hi[N-1] - Hi[N-2])
        dq = 1./dx*(Qi[N-1] - Qi[N-2])
        Hi[N:Ntot] = Hi[N-1] + dh*(Xi[N:Ntot] - Xi[N-1])
        Qi[N:Ntot] = Qi[N-1] + dq*(Xi[N:Ntot] - Xi[N-1])

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Cell faces values hj, qj and uj at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        
        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt/2 (explicit stage)
        # ------------------------------------------------------------------------------------------------
        #-
        
        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-

#RB
#RB Verif
        data=(dx,dt,uj0,hj0,g)
        beta = fsolve (findposRL1, Cr,  args=data ) /2.


        p = floor(beta)
        b = beta - p
        p = int(p)
        uR0 = (1-b)*uj0[p]+b*uj0[p+1];
        hR0 = (1-b)*hj0[p]+b*hj0[p+1];    
        DxfR0 = (1-b)*Dxfj[p]+b*Dxfj[p+1];
     
        #Water depth and velocity for incident wave
        hL0 = DataManip(t+dt/2.,h0+offset,DAT)
        uL0 = (g*hL0)**0.5*(hL0+fj[0])/hL0
        
        IR=uR0 -2*(g*hR0)**0.5 - dt/2.*g*DxfR0 # Variable de Riemann associee a C-

        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + 2.*(g*hL0) ** 0.5   #- dot(dot(dot(0,dt)/2.,g),Dxfj(1))

        #-
        # Boundary values for water depth and depth-averaged velocity at t=t+dt/2
        #-        
        uA = 1./2.*(IL + IR)
        hA = 1./(16.*g)*(IL - IR)**2
        
        #-
        # Cell face values reconstruction for water depth h
        #-
        hj = CellFaceInt( dx, Hi[0:Next], ADr, hA )
        Dxhj  = Deriv1j( hj[0:Next+1], dx, ADxjr  )
        Dxxhj = Deriv2j( hj[0:Next+1], dx, ADxxjr )

        #-
        # Water depth i-values
        #-
        hi = 3./2.*Hi[0:Next] - 1./4.*(hj[0:Next] + hj[1:Next+1])
        uj, qj = DeffCorrU(uA,Qi[0:Next],hi[0:Next],hj[0:Next+1],fj[0:Next+1],Dxhj[0:Next+1],Dxfj[0:Next+1],Dxxfj[0:Next+1],dx,ADr,BQr,uj[0:Next+1],betaD,alfa,tol,MaxIter,WDtol,nargout=2)
        Dxuj = Deriv1j(uj[0:Next+1],dx,ADxjr)
        Dxxuj= Deriv2j(uj[0:Next+1],dx,ADxxjr)


        # ------------------------------------------------------------------------------------------------
        # ----------------------------- Second Runge-Kutta stage -----------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
    

        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        jc, jt, MatWav = WaveProp(Xj[0:N+1],hj[0:N+1],fj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],WDtol,nargout=3)

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex(t,kTb,PHIb,PHIf,hj[0:N+1],uj[0:N+1],fj[0:N+1],MatWav,kBrWave,dx,dt,g,WDtol)

        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity(t,PHI1,PHI2,bCointe,alfab,alfaf,gamab,gamaf,kap1,kap2,kBrWave,Xj[0:N+1],hj[0:N+1],fj[0:N+1],dx,g,WDtol,nargout=3)
        Nu1j = np.concatenate( [ Nu1j[0:N], np.zeros(Ntot - N ) ] )
        Nu2j = np.concatenate( [ Nu2j[0:N], np.zeros(Ntot - N ) ] )

        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity(hj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Nu1j[0:N+1])
        FCi = 1./dx*( FCj[1:N+1] - FCj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj = FluxMomentum( qj[0:N],hj[0:N],fj[0:N],uj[0:N],Dxhj[0:N],Dxfj[0:N],Dxuj[0:N],Dxxhj[0:N],Dxxuj[0:N],Dxxfj[0:N],g,betaD,alfa,WDtol)
        FMi = 1./dx*( FMj[1:N+1] - FMj[0:N] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi = SourceMomentum( hi[0:N],hj[0:N+1],fi[0:N],fj[0:N+1],uj[0:N+1],Dxhj[0:N+1],Dxfj[0:N+1],Dxfi[0:N],Dxuj[0:N+1],Nu2j[0:N+1],Xi[0:N],g,betaD,alfa,fricFact,Cfi[0:N],WDtol)
        SMi = 1./dx*SMi
        DtHi = -FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Estimates of Hi and Qi at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH2 = dt*DtHi
        kQ2 = dt*DtQi
        Hi = Hi0[0,N-1] + 1./2.*kH2
        Qi = Qi0[0,N-1] + 1./2.*kQ2
        if FilterD1 == 1:
            Hi[arange(N - NIZ,N - 1)] = explicitFILT0 (Hi(arange(N - NIZ,N - 1)) )
            Qi[arange(N - NIZ,N - 1)] = explicitFILT0( Qi(arange(N - NIZ,N - 1)) )
        
        #-
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*( Hi[0:N-1] - Hi[0:N-2] )
        dq = 1./dx*( Qi[0:N-1] - Qi[0:N-2] )
        Hi[arange(N,Ntot - 1)] = Hi(N - 1) + dh*( Xi(arange(N,Ntot - 1) - Xi(N - 1)) )
        Qi[arange(N,Ntot - 1)] = Qi(N - 1) + dq*( Xi(arange(N,Ntot - 1) - Xi(N - 1)) )

        # ------------------------------------------------------------------------------------------------
        # ----------------------------------- Finding last wet cell --------------------------------------
        # ------------------------------------------------------------------------------------------------
        #-        
        N1 = max(find(hj > WDtol))
        N2 = min(find(hj < WDtol))
        Nm = min(N1,N2)

        if logical_and(logical_and((isempty(Nm) == 0),(Nm != N)),(Nm < (Ntot - NSZ))):
            if Nm > N:
                kH1 = concat([kH1(arange(1,N - 1)),interp1(Xi(arange(1,N - 1)),kH1(arange(1,N - 1)),Xi(arange(N,Nm - 1)),'linear','extrap')])
                kH2 = concat([kH2(arange(1,N - 1)),interp1(Xi(arange(1,N - 1)),kH2(arange(1,N - 1)),Xi(arange(N,Nm - 1)),'linear','extrap')])
                kQ1 = concat([kQ1(arange(1,N - 1)),interp1(Xi(arange(1,N - 1)),kQ1(arange(1,N - 1)),Xi(arange(N,Nm - 1)),'linear','extrap')])
                kQ2 = concat([kQ2(arange(1,N - 1)),interp1(Xi(arange(1,N - 1)),kQ2(arange(1,N - 1)),Xi(arange(N,Nm - 1)),'linear','extrap')])
                etamj = concat([etamj(arange(1,N)),interp1(Xj(arange(1,N)),etamj(arange(1,N)),Xj(arange(N + 1,Nm)),'linear','extrap')])
            N = Nm
            Next = N + NSZ
            Nint = N - NSZ

            #-
            # Matrix reduction
            #-
            ADxjr  = Comp_1st_Mat(Next)
            ADxir  = Comp_1st_Mat(Next - 1)
            ADxxjr = Comp_2nd_Mat(Next)
            ADr = Comp_1st_Mat(Next - 2)
            BQr = Cell_J_Mat(Next)

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Cell faces values hj, qj and uj at t=t+dt/2 -----------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt/2 (implicit stage)
        # ------------------------------------------------------------------------------------------------
        #-

        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-
        beta = fzero('findposRL2',concat([0,Cr]),options,dx,dt / 2,uj0,hj0,hj(1),uj(1),g)
        p = floor(beta)
        b = beta - p
        uR0 = dot((1 - b),uj0(p + 1)) + dot(b,uj0(p + 2))
        hR0 = dot((1 - b),hj0(p + 1)) + dot(b,hj0(p + 2))
        DxfR0 = dot((1 - b),Dxfj(p + 1)) + dot(b,Dxfj(p + 2))
        hL0 = DataManip(t + dt / 2,h0 + offset,DAT)
        uL0 = dot((dot(g,hL0)) ** 0.5,(hL0 + fj(1))) / hL0
        IR = uR0 - 2*(g*hR0) ** 0.5 - dt/2.*g*DxfR0
        
        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + dot(2,(dot(g,hL0)) ** 0.5) - dot(dot(dot(0,dt) / 2,g),Dxfj(1))
        
        #-
        # Boundary values for water depth and depth-averaged velocity at t=t+dt/2
        #-
        uA = 1./.2*(IL + IR)
        hA = 1./(16*g)*(IL - IR)** 2

        # ------------------------------------------------------------------------------------------------
        # Cell face values reconstruction for water depth h
        hj=CellFaceInt(dx,Hi[0:Next-1],ADr,hA)
        Dxhj=Deriv1j(hj[0:Next],dx,ADxjr)
        Dxxhj=Deriv2j(hj[0:Next],dx,ADxxjr)
        hi=3./.2*Hi[0:Next-1] - 1./4.*([0:Next-1] + hj[1:Next])
        if Next > len(uj):
            Nu = len(uj)
            du = dot(1 / dx,(uj(Nu) - uj(Nu - 1)))
            uj[arange(Nu + 1,Next)]=dot(du,(Xj(arange(Nu + 1,Next)) - Xj(Next)))
            if FilterD1 == 1:
                uj[arange(Nu - NIZ,Next)]=explicitFILT0(uj(arange(Nu - NIZ,Next)))
        uj, qj = DeffCorrU(uA,Qi(arange(1,Next - 1)),hi(arange(1,Next - 1)),hj(arange(1,Next)),fj(arange(1,Next)),Dxhj(arange(1,Next)),Dxfj(arange(1,Next)),Dxxfj(arange(1,Next)),dx,ADr,BQr,uj(arange(1,Next)),betaD,alfa,tol,MaxIter,WDtol,nargout=2)
        Dxuj  = Deriv1j(uj(arange(1,Next)),dx,ADxjr)
        Dxxuj = Deriv2j(uj(arange(1,Next)),dx,ADxxjr)
        hj0 = hj
        hi0 = hi
        uj0 = uj

        # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ------------------------------ Third Runge-Kutta stage -----------------------------------------
    
        # ------------------------------------------------------------------------------------------------
        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        #-
        jc,jt,MatWav = WaveProp( Xj[0:N], hj[0:N],fj[0:N], Dxhj[0:N], Dxfj[0:N], WDtol, nargout=3 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex( t, kTb, PHIb, PHIf, hj[0:N], uj[0:N], fj[0:N], MatWav, kBrWave, dx, dt, g, WDtol)
        
        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j, Nu2j, xb = EddyViscosity(t, PHI1, PHI2, bCointe, alfab, alfaf, gamab, gamaf, kap1, kap2, kBrWave, Xj[0:N], hj[0:N],fj[0:N], dx, g, WDtol, nargout=3)
        Nu1j = concat([Nu1j[0:N-1],np.zeros(Ntot - N + 1)])
        Nu2j = concat([Nu2j[0:N-1],np.zeros(Ntot - N + 1)])
        
        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity( hj[0:N], uj[0:N], Dxhj[0:N], Dxfj[0:N], Nu1j[0:N] )
        FCi = dot(1./dx,(FCj(arange(2,N)) - FCj(arange(1,N - 1))))

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj=FluxMomentum(qj[0:N], hj[0:N],fj[0:N], uj[0:N], Dxhj[0:N], Dxfj[0:N],Dxuj[0:N], Dxxhj[0:N], Dxxuj[0:N], Dxxfj[0:N], g, betaD, alfa, WDtol)
        FMi=dot(1./ dx,(FMj(arange(2,N)) - FMj(arange(1,N - 1))))

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi=SourceMomentum(hi[0:N-1],hj[0:N],fi[0:N-1],fj[0:N],uj[0:N],Dxhj[0:N],Dxfj[0:N],Dxfi[0:N-1],Dxuj[0:N],Nu2j[0:N],Xi[0:N-1],g,betaD,alfa,fricFact,Cfi[0:N-1],WDtol)
        SMi = 1./dx*SMi
        DtHi = - FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # --------------------------------- Estimates of Hi and Qi at t=t+dt -----------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH3=dt*DtHi
        kQ3=dt*DtQi
        Hi = Hi0[0:N-1] + kH3
        Qi = Qi0[0:N-1] + kQ3
        if FilterD1 == 1:
            Hi[arange(N - NIZ,N - 1)] = explicitFILT0( Hi(arange(N - NIZ,N - 1)) )
            Qi[arange(N - NIZ,N - 1)] = explicitFILT0( Qi(arange(N - NIZ,N - 1)) )
        
        #-     
        # Linear extrapolation for dry cells
        #-
        dh = 1./dx*(Hi(N - 1) - Hi(N - 2))
        dq = 1./dx*(Qi(N - 1) - Qi(N - 2))
        Hi[arange(N,Ntot - 1)] = Hi(N - 1) + dot(dh,(Xi(arange(N,Ntot - 1)) - Xi(N - 1)))
        Qi[arange(N,Ntot - 1)] = Qi(N - 1) + dot(dq,(Xi(arange(N,Ntot - 1)) - Xi(N - 1)))

        # ------------------------------------------------------------------------------------------------
        # ------------------------ Cell faces values hj, qj and uj at t=t+dt -----------------------------
        # ------------------------------------------------------------------------------------------------
        
        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt (explicit stage)
        # ------------------------------------------------------------------------------------------------
        #
        
        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-
        beta = fzero( 'findposRL1', concat([0,Cr]), options, dx, dt/2., uj0, hj0, g )
        p = floor(beta)
        b = beta - p
        uR0 = (1 - b)*uj0(p + 1) + b*uj0(p + 2)
        hR0 = dot((1 - b),hj0(p + 1)) + dot(b,hj0(p + 2))
        DxfR0 = dot((1 - b),Dxfj(p + 1)) + dot(b,Dxfj(p + 2))
        hL0 = DataManip(t + dt,h0 + offset,DAT)
        uL0 = dot((dot(g,hL0)) ** 0.5,(hL0 + fj(1))) / hL0
        IR = uR0 - 2.*(g*hR0)**0.5 - dt/2.*g*DxfR0
        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + dot(2,(dot(g,hL0)) ** 0.5) - dot(dot(dot(0,dt) / 2,g),Dxfj(1))
        #-
        # Boundary values for water depth and depth-averaged velocity at t=t+dt/2
        #-
        uA = 1./2.*( IL + IR )
        hA = 1./(16.*g)*( IL - IR )** 2

        #- 
        # Cell face values reconstruction for water depth h
        #-        
        hj = CellFaceInt( dx, Hi[0,Next-1], ADr, hA )
        Dxhj =  Deriv1j( hj[0:Next], dx, ADxjr  )
        Dxxhj = Deriv2j( hj[0:Next], dx, ADxxjr )
        hi = dot(3. / 2.,Hi(arange(1,Next - 1))) - dot(1 / 4,(hj(arange(1,Next - 1)) + hj(arange(2,Next))))
        uj, qj = DeffCorrU( uA,Qi(arange(1,Next - 1)), hi(arange(1,Next - 1)), hj(arange(1,Next)),fj(arange(1,Next)),Dxhj(arange(1,Next)),Dxfj(arange(1,Next)),Dxxfj(arange(1,Next)),dx,ADr,BQr,uj(arange(1,Next)),betaD,alfa,tol,MaxIter,WDtol,nargout=2)
        Dxuj   = Deriv1j( uj[0:Next], dx, ADxjr )
        Dxxuj  = Deriv2j( uj[0:Next], dx, ADxxjr)

        # ------------------------------------------------------------------------------------------------
        # ----------------------------- Fourth Runge-Kutta stage -----------------------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # ----------------------- Indentify wave crest and trough positions ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        jc,jt,MatWav = WaveProp( Xj[0:N], hj[0:N], fj[0:N], Dxhj[0:N], Dxfj[0:N], WDtol, nargout=3 )

        # ------------------------------------------------------------------------------------------------
        # ---------------------- Actualization of the breaking event index -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kBrWave = BrWaveIndex( t, kTb, PHIb, PHIf, hj[0:N], uj[0:N], fj[0:N], MatWav, kBrWave, dx, dt, g, WDtol )

        # ------------------------------------------------------------------------------------------------
        # ------------------- Breaking criterium and eddy viscosity coefficients -------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        Nu1j,Nu2j,xb = EddyViscosity( t, PHI1, PHI2, bCointe, alfab, alfaf, gamab, gamaf, kap1, kap2, kBrWave, Xj[0:N], hj[0:N], fj[0:N], dx, g, WDtol, nargout=3)
        Nu1j = concat([Nu1j[0:N-1], np.zeros(Ntot-N+1)])
        Nu2j = concat([Nu2j[0:N-1], np.zeros(Ntot-N+1)])

        # ------------------------------------------------------------------------------------------------
        # -------------------------- Flux function for continuity equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FCj = FluxContinuity( hj[0:N], uj[0:N], Dxhj[0:N], Dxfj[0:N], Nu1j[0:N] )
        FCi = 1./dx*( FCj[1:N] - FCj[0:N-1] )

        # ------------------------------------------------------------------------------------------------
        # ---------------------------- Flux function for momemtum equation  ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        FMj = FluxMomentum( qj[0:N], hj[0:N], fj[0:N], uj[0:N], Dxhj[0:N], Dxfj[0:N], Dxuj[0:N], Dxxhj[0:N], Dxxuj[0:N], Dxxfj[0:N], g, betaD, alfa, WDtol )
        FMi = 1./dx*( FMj[1:N] - FMj[0:N-1] )

        # ------------------------------------------------------------------------------------------------
        # --------------------------- Source function for momemtum equation ------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        SMi = SourceMomentum( hi[0:N-1], hj[0:N], fi[0:N-1], fj[0:N], uj[0:N], Dxhj[0:N], Dxfj[0:N], Dxfi[0:N-1], Dxuj[0:N], Nu2j[0:N], Xi[0:N-1], g, betaD, alfa, fricFact, Cfi[0:N-1], WDtol )
        SMi = 1./dx*SMi
        DtHi = -FCi
        DtQi = -FMi + SMi

        # ------------------------------------------------------------------------------------------------
        # ------------------------------- Estimates of Hi and Qi at t=t+dt -------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        kH4 = dt*DtHi
        kQ4 = dt*DtQi
        Hi = Hi0[0:N] + (kH1[0:N-1] + 2.*kH2[0:N-1] + 2.*kH3[0:N-1] + kH4[0:N-1]) / 6.
        Qi = Qi0[0:N] + (kQ1[0:N-1] + 2.*kQ2[0:N-1] + 2.*kQ3[0:N-1] + kQ4[0:N-1]) / 6.
        if FilterD1 == 1:
            Hi[arange(N - NIZ,N - 1)] = explicitFILT0(Hi(arange(N - NIZ,N - 1)))
            Qi[arange(N - NIZ,N - 1)] = explicitFILT0(Qi(arange(N - NIZ,N - 1)))
        
        #-
        # Linear extrapolation for dry cells
        #-
        dh = dot(1 / dx,(Hi(N - 1) - Hi(N - 2)))
        dq = dot(1 / dx,(Qi(N - 1) - Qi(N - 2)))
        Hi[arange(N,Ntot - 1)] = Hi(N - 1) + dot(dh,(Xi(arange(N,Ntot - 1)) - Xi(N - 1)))
        Qi[arange(N,Ntot - 1)] = Qi(N - 1) + dot(dq,(Xi(arange(N,Ntot - 1)) - Xi(N - 1)))
        
        #-
        # High order linear filter to dump out small peturbations
        #-
        if FilterD2 == 1:
            if NFT == 0:
                dum = 0
                varFn = varFa
            else:
                dum = 1
                varFn=floor( t / (NFT*dt) )
            if logical_or((varFn > varFa),(dum == 0)):
                Hi = implicitFILT8( Hi, alfaF )
                Qi = implicitFILT8( Qi, alfaF )
            varFa = varFn

        Hi0 = Hi
        Qi0 = Qi

        # ------------------------------------------------------------------------------------------------
        # ----------------------------------- Finding last wet cell --------------------------------------
        # ------------------------------------------------------------------------------------------------
        #-
        N1 = max(find(hj > WDtol))
        N2 = min(find(hj < WDtol))
        Nm = min(N1,N2)
        if logical_and(logical_and((isempty(Nm) == 0),(Nm != N)),(Nm < (Ntot - NSZ))):
            if Nm > N:
                etamj=concat([etamj(arange(1,N)),interp1(Xj(arange(1,N)),etamj(arange(1,N)),Xj(arange(N + 1,Nm)),'linear','extrap')])
            N=copy(Nm)
            Next=N + NSZ
            Nint=N - NSZ
            #-
            # Matrix reduction
            #-
            ADxjr  = Comp_1st_Mat( Next  )
            ADxir  = Comp_1st_Mat( Next-1)
            ADxxjr = Comp_2nd_Mat( Next  )
            ADr = Comp_1st_Mat( Next-2 )
            BQr = Cell_J_Mat( Next )
        
        # ------------------------------------------------------------------------------------------------
        # ------------------------ Cell faces values hj, qj and uj at t=t+dt -----------------------------
        # ------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------
        # Left boundary condition for h and u at t=t+dt (implicit stage)
        # ------------------------------------------------------------------------------------------------
        #-

        #-
        # Initial location of left going characteristic (xR=beta*dx) + water and depth-averaged velocity values
        #-
        beta=fzero('findposRL2',concat([0,Cr]),options,dx,dt / 2,uj0,hj0,hj(1),uj(1),g)
        p = floor(beta)
        b = beta - p
        uR0 = dot((1 - b),uj0(p + 1)) + dot(b,uj0(p + 2))
        hR0 = dot((1 - b),hj0(p + 1)) + dot(b,hj0(p + 2))
        DxfR0 = dot((1 - b),Dxfj(p + 1)) + dot(b,Dxfj(p + 2))
        hL0 = DataManip(t + dt,h0 + offset,DAT)
        uL0 = dot((dot(g,hL0)) ** 0.5,(hL0 + fj(1))) / hL0
        IR = uR0 - dot(2,(dot(g,hR0)) ** 0.5) - dot(dot(dt / 2,g),DxfR0)
        
        #-
        # Riemann variable for right going characteristic
        #-
        IL = uL0 + dot(2,(dot(g,hL0)) ** 0.5) - dot(dot(dot(0,dt) / 2,g),Dxfj(1))

        #-
        # Estimation de u et h a l'entree pour t=t+dt
        #-
        uA = 1./2.*(IL + IR)
        hA = 1./(16.*g)*(IL - IR) ** 2
        hout = dot(1. / (dot(16,g)),(dot(2,(dot(g,h0)) ** 0.5) - dot(dot(dt / 2,g),Dxfj(1)) - IR) ** 2)
        
        #-
        # Cell face values reconstruction for water depth h
        #-
        hj = CellFaceInt(dx,Hi(arange(1,Next - 1)),ADr,hA)
        Dxhj  = Deriv1j(hj(arange(1,Next)),dx,ADxjr)
        Dxxhj = Deriv2j(hj(arange(1,Next)),dx,ADxxjr)
        hi = dot(3 / 2,Hi(arange(1,Next - 1))) - dot(1 / 4,(hj(arange(1,Next - 1)) + hj(arange(2,Next))))
        if Next > len(uj):
            Nu = len(uj)
            du = dot(1 / dx,(uj(Nu) - uj(Nu - 1)))
            uj[arange(Nu + 1,Next)]=dot(du,(Xj(arange(Nu + 1,Next)) - Xj(Next)))
            if FilterD1 == 1:
                uj[arange(Nu - NIZ,Next)] = explicitFILT0( uj(arange(Nu - NIZ,Next)) )
        uj,qj, iter = DeffCorrU(uA,Qi(arange(1,Next - 1)),hi(arange(1,Next - 1)),hj(arange(1,Next)),fj(arange(1,Next)),Dxhj(arange(1,Next)),Dxfj(arange(1,Next)),Dxxfj(arange(1,Next)),dx,ADr,BQr,uj(arange(1,Next)),betaD,alfa,tol,MaxIter,WDtol,nargout=3)
        Dxuj  = Deriv1j( uj[0:], dx, ADxjr  )
        Dxxuj = Deriv2j( uj[0:], dx, ADxxjr )
        hj0 = hj
        hi0 = hi
        uj0 = uj
        
        t = t+dt
        if logical_or((max(abs(Hi)) > 1000.0),(N < NSZ)):
            llwr=1
            break

       
    VOLT = np.sum(VolIn) / WaterVol[0]
    VOLF = WaterVol[i - 1] / WaterVol[0]
    VOLP = (np.sum(VolIn) - (WaterVol[i-1] - WaterVol[0]) / WaterVol[0]
    # ----------------------------------------------------------------------------------------------------
    print( '%s %6.3f %s \\n', 'Total volume of water that has entered : Vin/V0 = ', 100*VOLT,'%' )
    print( '%s %6.3f %s \\n', 'Final volume of water in the domain    : Vf/V0  = ', 100*VOLF,'%' )
    print( '%s %6.3f %s \\n', 'Lost volume of water : (Vin-(Vf-V0))/V0 = ', 100*VOLP,'%' )
    
    ui=interp1(Xj(arange(1,Next)),uj(arange(1,Next)),Xi(arange(1,Next - 1)),'cubic')
    
    Uwi=concat([ui(arange(1,Next - 1)),interp1(Xi(arange(Next - 11,Next - 1)),ui(arange(Next - 11,Next - 1)),Xi(arange(Next,Ntot - 1)),'linear','extrap')])
    fprintf(fidUi,'%6.8f \\t',Uwi)
    ndt=len(Time)
    fprintf(fidParam,'%6.8f \\t',concat([H0,h0,T0,L0,dx,dt,Ntot,Tf,ndt,epsilon,kh0,slope]))
    fclose('all')
    save(concat([carpetaN,'/condlim.mat']),'Time','a0','T0','L0','h0','Xlong','hLeft','uLeft','hRight','uRight','WaterVol','VolIn','dx','dt','g')
   # llwr=isempty(lastwarn)
    return t,llwr